/**
 * @fileoverview	API.
 * @author			Danny Hvam <danny@etilbudsavis.dk>
 */
package com.eTilbudsavis.etasdk;

import java.io.IOException;
import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;

import org.apache.http.Header;
import org.apache.http.HttpResponse;
import org.apache.http.NameValuePair;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.HttpDelete;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.methods.HttpPut;
import org.apache.http.client.utils.URLEncodedUtils;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.conn.ssl.X509HostnameVerifier;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.DefaultHttpRoutePlanner;
import org.apache.http.impl.conn.SingleClientConnManager;
import org.apache.http.message.BasicHeader;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.protocol.HTTP;
import org.apache.http.util.EntityUtils;
import org.json.JSONObject;

import android.os.Bundle;
import android.text.TextUtils;

import com.eTilbudsavis.etasdk.EtaCache.CacheItem;
import com.eTilbudsavis.etasdk.Session.SessionListener;
import com.eTilbudsavis.etasdk.EtaObjects.Catalog;
import com.eTilbudsavis.etasdk.EtaObjects.Dealer;
import com.eTilbudsavis.etasdk.EtaObjects.EtaError;
import com.eTilbudsavis.etasdk.EtaObjects.Offer;
import com.eTilbudsavis.etasdk.EtaObjects.Store;
import com.eTilbudsavis.etasdk.Utils.Endpoint;
import com.eTilbudsavis.etasdk.Utils.Params;
import com.eTilbudsavis.etasdk.Utils.Sort;
import com.eTilbudsavis.etasdk.Utils.Tools;

public class Api implements Serializable {
	
	private static final long serialVersionUID = 1L;
	
	public static final String TAG = "Api";
	
	public static final String API_KEY = Params.API_KEY;
	
	/** Header name for the session token */
	public static final String HEADER_X_TOKEN = Params.HEADER_X_TOKEN;

	/** Header name for the session token expiration date */
	public static final String HEADER_X_TOKEN_EXPIRES = "X-Token-Expires";
	
	/** Header name for the signature generated by the app */
	public static final String HEADER_X_SIGNATURE = Params.HEADER_X_SIGNATURE;

	public static final String HEADER_CONTENT_TYPE = Params.HEADER_CONTENT_TYPE;
	
	/** The default page limit for API calls */
	public static final int DEFAULT_OFFSET = Params.DEFAULT_OFFSET;

	/** The default page limit for API calls */
	public static final int DEFAULT_LIMIT = Params.DEFAULT_LIMIT;
	
	/**
	 * Expected return type. Default is JSON.<br><br>
	 * <i>Other types are not implemented yet.</i><br>
	 * TODO: Complete implementation
	 */
	public enum AcceptType {
		XML		{ public String toString() { return "application/xml, text/xml"; } },
		CSV		{ public String toString() { return "application/csv"; } },
		JSON	{ public String toString() { return "application/json"; } }
	}
	
	/**
	 * Type of HTTP request.<br><br>
	 * <i>OPTIONS and HEAD are not implemented yet.</i><br>
	 */
	public enum RequestType {
		POST, GET, PUT, DELETE, OPTIONS, HEAD
	}
	
	/**
	 * Content-Type used in request. Default is URLENCODED<br><br>
	 * <i>Other types are not implemented yet.</i><br>
	 * TODO: Complete implementation
	 */
	public enum ContentType {
		JSON			{ public String toString() { return "application/json; charset=utf-8"; } },
		URLENCODED	{ public String toString() { return "application/x-www-form-urlencoded; charset=utf-8"; } },
		FORMDATA		{ public String toString() { return "multipart/form-data; charset=utf-8"; } }
	}

	private Eta mEta;
	
	private static final int CONNECTION_TIME_OUT = 10000;
	
	private Callback mListener = null;
	
	private String mUrl = null;
	private Bundle mApiParams = null;
	private RequestType mRequestType = null;
	private ContentType mContentType = null;
	private List<NameValuePair> mQuery;
	private List<Header> mHeaders;

	private HttpResponse mResponse = null;
	private int mStatusCode = -1;
	private String mData = "";
	
	private String mId = null;
	private boolean mSessionRefreshCall = false;
	private boolean mCacheHit = false;
	private boolean mMultipleCallbacks = false;

	
	private boolean mUseLocation = true;
	private boolean mUseCache = true;
	private boolean mPrintDebug = false;
	private boolean mCanceled = false;
	
	/**
	 * TODO: Write proper JavaDoc<br>
	 * <code>new String[] {Api.SORT_DISTANCE, Api.SORT_PUBLISHED}</code>
	 * @param order
	 * @return This {@link com.eTilbudsavis.etasdk.Api Api} object to allow for chaining of calls to set methods
	 */
	public Api setOrderBy(String order) {
		mApiParams.putString(Sort.ORDER_BY, order);
		return this;
	}

	public Api setOrderBy(List<String> order) {
		String tmp = TextUtils.join(",",order);
		mApiParams.putString(Sort.ORDER_BY, tmp);
		return this;
	}
	
	public String getOrderBy() {
		return mApiParams.getString(Sort.ORDER_BY);
	}

	/**
	 * Sets a list of id's to filter result by.
	 * @param id's to filter by
	 * @return this object
	 */
	public Api setCatalogIds(List<String> ids) {
		applyFilter(Params.FILTER_CATALOG_IDS, ids);
		return this;
	}

	/**
	 * Returns a list of id's that this {@link com.eTilbudsavis.etasdk.Api Api} will filter results by.
	 * @return a list if id's
	 */
	public List<String> getCatalogIds() {
		return getFilter(Params.FILTER_CATALOG_IDS);
	}

	/**
	 * Sets a list of id's to filter result by.
	 * @param id's to filter by
	 * @return this object
	 */
	public Api setDealerIds(List<String> ids) {
		applyFilter(Params.FILTER_DEALER_IDS, ids);
		return this;
	}

	/**
	 * Returns a list of id's that this {@link com.eTilbudsavis.etasdk.Api Api} will filter results by.
	 * @return a list if id's
	 */
	public List<String> getDealerIds() {
		return getFilter(Params.FILTER_DEALER_IDS);
	}

	/**
	 * Sets a list of id's to filter result by.
	 * @param id's to filter by
	 * @return this object
	 */
	public Api setStoreIds(List<String> ids) {
		applyFilter(Params.FILTER_STORE_IDS, ids);
		return this;
	}

	/**
	 * Returns a list of id's that this {@link com.eTilbudsavis.etasdk.Api Api} will filter results by.
	 * @return a list if id's
	 */
	public List<String> getStoreIds() {
		return getFilter(Params.FILTER_STORE_IDS);
	}

	/**
	 * Sets a list of id's to filter result by.
	 * @param id's to filter by
	 * @return this object
	 */
	public Api setOfferIds(List<String> ids) {
		applyFilter(Params.FILTER_OFFER_IDS, ids);
		return this;
	}

	/**
	 * Returns a list of id's that this {@link com.eTilbudsavis.etasdk.Api Api} will filter results by.
	 * @return a list if id's
	 */
	public List<String> getOfferIds() {
		return getFilter(Params.FILTER_OFFER_IDS);
	}

	/**
	 * Sets a list of id's to filter result by.
	 * @param ids to filter by
	 * @return this object
	 */
	public Api setAreaIds(List<String> ids) {
		applyFilter(Params.FILTER_AREA_IDS, ids);
		return this;
	}

	/**
	 * Returns a list of id's that this {@link com.eTilbudsavis.etasdk.Api Api} will filter results by.
	 * @return a list if id's
	 */
	public List<String> getAreaIds() {
		return getFilter(Params.FILTER_AREA_IDS);
	}
	
	/**
	 * Set a parameter for what specific id's to get from a given endpoint.<br><br>
	 * 
	 * E.g.: setIds(Catalog.PARAM_IDS, new String[]{"eecdA5g","b4Aea5h"});
	 * @param	filterName of the endpoint parameter e.g. Catalog.PARAM_IDS
	 * @param	ids to filter by
	 * @return	this object
	 */
	public Api applyFilter(String filterName, List<String> ids) {
		String tmp = TextUtils.join(",",ids);
		mApiParams.putString(filterName, tmp);
		return this;
	}
	
	public Api removeFilter(String filterName) {
		mApiParams.remove(filterName);
		return this;
	}
	
	/**
	 * Returns a list of id's that this {@link com.eTilbudsavis.etasdk.Api Api} will filter results by.
	 * @param	filterName 
	 * @return	a list if id's
	 */
	public List<String> getFilter(String filterName) {
		String tmp = mApiParams.getString(filterName);
		List<String> list = new ArrayList<String>();
		Collections.addAll(list, TextUtils.split(tmp, ","));
		return list;
	}
	
	/**
	 * Set a parameter for what specific id to get from a given endpoint.<br><br>
	 * 
	 * E.g.: setIds(Catalog.PARAM_IDS, "b4Aea5h");
	 * @param id to filter by
	 * @return this object
	 */
	public Api setId(String id) {
		mId = id;
		return this;
	}
	
	public String getId() {
		return mId;
	}
	
	public Api setContentType(ContentType type) {
		mContentType = type;
		return this;
	}

	public ContentType getContentType() {
		return mContentType;
	}

	public Api setRequestType(RequestType type) {
		mRequestType = type;
		return this;
	}

	public RequestType getRequestType() {
		return mRequestType;
	}

	public Bundle getApiParameters() {
		return mApiParams;
	}
	
	public Api addApiParameters(Bundle params) {
		mApiParams.putAll(params);
		return this;
	}
	
	public Api setApiParameters(Bundle params) {
		mApiParams = params;
		return this;
	}

	public String getUrl() {
		return mUrl;
	}

	public Api setUrl(String url) {
		mUrl = url;
		return this;
	}

	public Callback<?> getListener() {
		return mListener;
	}

	public Api setListener(CallbackString listener) {
		mListener = listener;
		return this;
	}
	
	/**
	 * Set any headers that you want in this API call. This should not generally
	 * be used, as the SDK handles all headers.
	 * @param name the name of the header.
	 * @param value the value of the header.
	 * @return This {@link com.eTilbudsavis.etasdk.Api Api} object to allow for chaining of calls to set methods
	 */
	public Api setHeader(String name, String value) {
		mHeaders.add(new BasicHeader(name, value));
		return this;
	}
	
	/**
	 * Get a list of the headers that this API call will send to server.<br>
	 * <b>Note</b> that X-Token a X-Signature is not included in this bundle.
	 * @return List of headers.
	 */
	public List<Header> getHeaders() {
		return mHeaders;
	}

	public Api setUseCache(boolean useCache) {
		mUseCache = useCache;
		return this;
	}
	
	public boolean useCache() {
		return mUseCache;
	}
	
	/**
	 * 
	 * @param multipleCallbacks
	 * @return
	 */
	public Api setMultipleCallbacks(boolean multipleCallbacks) {
		mMultipleCallbacks = multipleCallbacks;
		return this;
	}
	
	public boolean useMultipleCallbacks() {
		return mMultipleCallbacks = false;
	}

	/**
	 * Whether to use location for this API call
	 * @param useLocation
	 * @return
	 */
	public Api setUseLocation(boolean useLocation) {
		this.mUseLocation = useLocation;
		return this;
	}

	/**
	 * Determine whether location is being used, for this API call
	 * @return True if location is being used, false otherwise.
	 */
	public boolean useLocation() {
		return mUseLocation;
	}

	/**
	 * Whether to print debug information to LogCat.<br><br>
	 * Prints URL, query and headers before execute. <br>
	 * And prints return headers, and the raw date of the reply.
	 * @param useDebug
	 * @return this object
	 */
	public Api setDebug(boolean useDebug) {
		this.mPrintDebug = useDebug;
		return this;
	}

	/**
	 * Tells whether the current {@link com.etilbudsavis.etasdk.API Api()} is printing debug information
	 */
	public boolean isDebug() {
		return mPrintDebug;
	}

	/**
	 * Attempts to cancel execution of this task.<br><br>
	 * This is just as cancelable as any other thread. (no guarantees)
	 * @param cancleIfPossible
	 * @return this object
	 */
	public synchronized Api cancel(boolean cancleIfPossible) {
		this.mCanceled = cancleIfPossible;
		return this;
	}

	/**
	 * Tells whether the current {@link com.etilbudsavis.etasdk.API Api()} is printing debug information
	 */
	public synchronized boolean isCanceled() {
		return mCanceled;
	}
	
	
	
	/**
	 * Default constructor for API
	 * @param Eta object with relevant information e.g. location
	 */
	public Api(Eta eta) {
		mEta = eta;
	}

	public Api search(String url, Callback<?> listener, String query) {
		if (!url.matches(Endpoint.SEARCH))
			Tools.logd(TAG, "url does not match a search endpoint, don't expect anything good...");
		
		Bundle apiParams = new Bundle();
		apiParams.putString(Params.QUERY, query);
		return request(url, listener, apiParams, RequestType.GET, ContentType.URLENCODED, null);
	}

	public Api get(String url, Callback<?> listener) {
		return request(url, listener, null, RequestType.GET, ContentType.URLENCODED, null);
	}

	public Api get(String url, Callback<?> listener, Bundle apiParams) {
		return request(url, listener, apiParams, RequestType.GET, ContentType.URLENCODED, null);
	}

	public Api post(String url, Callback<?> listener, Bundle apiParams) {
		return request(url, listener, apiParams, RequestType.POST, ContentType.URLENCODED, null);
	}

	public Api delete(String url, Callback<?> listener, Bundle apiParams) {
		return request(url, listener, apiParams, RequestType.DELETE, ContentType.URLENCODED, null);
	}

	public Api put(String url, Callback<?> listener, Bundle apiParams) {
		return request(url, listener, apiParams, RequestType.PUT, ContentType.URLENCODED, null);
	}
	
	public Api request(String url, Callback<?> listener, Bundle apiParams, RequestType requestType, ContentType contentType, List<Header> headers) {
		if (url == null || listener == null || requestType == null ) {
			Tools.logd(TAG, "Api parameters error: url, callback interface and requestType must not be null");
			return null;
		}
		
		mUrl = url;
		mListener = listener;
		mApiParams = apiParams == null ? new Bundle() : apiParams;
		mRequestType = requestType;
		mContentType = contentType == null ? ContentType.URLENCODED : contentType;
		mHeaders = headers == null ? new ArrayList<Header>(3) : headers;
		return this;
	}

	/**
	 * This will start executing the request.
	 * Note that if the {@link #request(String, CallbackJSON, Bundle, RequestType, Bundle) request()}'s 
	 * optionalKeys bundle contains options that have also been set by
	 * any of the Api-setters, then the setters will be used.
	 * @return HttpHelper, so execution of background task can be cancelled. <br>
	 * <b>Note</b> HttpHelper is <code>null</code> if there is no valid session. In this case
	 * {@link #execute() execute()} will try to get a valid session and then instantiate HttpHelper, here after the previous call is continued.
	 */
	public Api execute() {

		// Check if all variables needed are okay
		if (mUrl == null || mListener == null || mApiParams == null || mRequestType == null || mHeaders == null) {
			Tools.logd(TAG, "A request() must be made before execute()");
			return null;
		}

		if (mId != null) {
			if (Endpoint.isItemEndpoint(mUrl)) {
				mUrl = mUrl + mId;
			} else {
				Tools.logd(TAG, "Id does not match a single id endpoint, continuing without id");
			}
		}
		
		// Is Session okay? If not, check if it's a session call? If not try to make a session before continuing
		if (mEta.getSession().getToken() == null || mEta.getSession().isExpired()) {
			if (!mUrl.matches(Endpoint.SESSION)) {
				SessionListener sl = new SessionListener() {
					
					public void onUpdate() {
						if (mEta.getSession().isExpired()) {
							mEta.getSession().unSubscribe(this);
							runThread();
						} else {
							mEta.getSession().update();
						}
					}
				};
				mEta.getSession().subscribe(sl).update();
			} else {
				runThread();
			}
		} else {
			runThread();
		}
		
		return Api.this;
	}
	
	private void runThread() {
		
		mEta.getThreadPool().execute(new Runnable() {
			
			public void run() {

				if (terminate()) return; 
				prepareQuery();

				if (terminate()) return; 
				printDebugPreExecute();

				if (terminate()) return; 
				performHttpCall();

				if (terminate()) return; 
				printDebugPostExecute();

				if (terminate()) return; 
				processResult();
				
			}
		});
	}
	
	private boolean terminate() {
		
		if (isCanceled()) { 
			Tools.logd(TAG, "Task canceled, terminating execution"); 
			return true;
		}
		return false;
	}

	private void prepareQuery() {

		// Prepare data.
		mQuery = new ArrayList<NameValuePair>();

		// Add optional data.
		if (!mApiParams.isEmpty()) {
			Iterator<String> iterator = mApiParams.keySet().iterator();
			while (iterator.hasNext()) {
				String s = iterator.next();
				Tools.putNameValuePair(mQuery, s, mApiParams.get(s));
			}
		}
		
		// Required API key.
		Tools.putNameValuePair(mQuery, API_KEY, mEta.getApiKey());

		if (mUseLocation && mEta.getLocation().isLocationSet()) {

			EtaLocation l = mEta.getLocation();
			Tools.putNameValuePair(mQuery, EtaLocation.LATITUDE, l.getLatitude());
			Tools.putNameValuePair(mQuery, EtaLocation.LONGITUDE, l.getLongitude());
			Tools.putNameValuePair(mQuery, EtaLocation.SENSOR, l.getSensor());
			Tools.putNameValuePair(mQuery, EtaLocation.RADIUS, l.getRadius());

			// Determine whether to include bounds.
			if (mEta.getLocation().isBoundsSet()) {
				Tools.putNameValuePair(mQuery, EtaLocation.BOUND_EAST, l.getBoundEast());
				Tools.putNameValuePair(mQuery, EtaLocation.BOUND_NORTH, l.getBoundNorth());
				Tools.putNameValuePair(mQuery, EtaLocation.BOUND_SOUTH, l.getBoundSouth());
				Tools.putNameValuePair(mQuery, EtaLocation.BOUND_WEST, l.getBoundWest());
			}
				
		}
		

		// Set headers if session is OK
		if (mEta.getSession().getToken() != null) {
			setHeader(HEADER_X_TOKEN, mEta.getSession().getToken());
			String sha256 = Tools.generateSHA256(mEta.getApiSecret() + mEta.getSession().getToken());
			setHeader(HEADER_X_SIGNATURE, sha256);
		}
		
		setHeader(HEADER_CONTENT_TYPE, mContentType.toString());
		

		// TODO: Check cache before executing the httpHepler
		if (mUseCache && mRequestType == RequestType.GET && mId != null) {
			String prefix = mUrl.contains(Endpoint.CATALOG_ID) ? "ern:catalog:" :
				mUrl.contains(Endpoint.DEALER_ID) ? "ern:dealer:" :
					mUrl.contains(Endpoint.STORE_ID) ? "ern:store:" : 
						mUrl.contains(Endpoint.OFFER_ID) ? "ern:offer:" : "";
			
			CacheItem c = mEta.getCache().get(prefix + mId);
			if (c != null) {
				mCacheHit = true;
				runOnUiThread(c.statuscode, c.object, null);
			}
			
		}
		
	}
	
	private void performHttpCall() {

		// Start the interwebs work stuff
		DefaultHttpClient httpClient = new DefaultHttpClient();
		
		// Use custom HostVerifier to accept our wildcard SSL Certificates: *.etilbudsavis.dk
		HostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;
		
		SSLSocketFactory socketFactory = SSLSocketFactory.getSocketFactory();
		socketFactory.setHostnameVerifier((X509HostnameVerifier) hostnameVerifier);
		SchemeRegistry registry = new SchemeRegistry();
		registry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
		registry.register(new Scheme("https", socketFactory, 443));
		SingleClientConnManager mgr = new SingleClientConnManager(httpClient.getParams(), registry);
		
		httpClient = new DefaultHttpClient(mgr, httpClient.getParams());
		HttpConnectionParams.setConnectionTimeout(httpClient.getParams(), CONNECTION_TIME_OUT);
		HttpConnectionParams.setSoTimeout(httpClient.getParams(), CONNECTION_TIME_OUT);
		
		// Change RoutePlanner to avoid SchemeRegistry causing IllegalStateException.
		// Some devices with faults in their default route planner
		httpClient.setRoutePlanner(new DefaultHttpRoutePlanner(registry));
		
		HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);
		// End SSL Certificates hack

		String tmpUrl;
		try {
			
			// Execute the correct request type
			switch (mRequestType) {
			case POST:
				
				HttpPost post = new HttpPost(mUrl);
				if (mQuery.size() > 0)
					post.setEntity(new UrlEncodedFormEntity(mQuery, HTTP.UTF_8));

				for (Header h : mHeaders)
					post.setHeader(h);
				
				mResponse = httpClient.execute(post);
				break;

			case GET:
				
				tmpUrl = mUrl;
				if (mQuery.size() > 0)
					tmpUrl += "?" + URLEncodedUtils.format(mQuery, HTTP.UTF_8);

				HttpGet get = new HttpGet(tmpUrl);
				
				for (Header h : mHeaders)
					get.setHeader(h);
				
				mResponse = httpClient.execute(get);
				break;

			case PUT:
				
				HttpPut put = new HttpPut(mUrl);
				if (mQuery.size() > 0)
					put.setEntity(new UrlEncodedFormEntity(mQuery, HTTP.UTF_8));
				
				for (Header h : mHeaders)
					put.setHeader(h);
				
				mResponse = httpClient.execute(put);
				break;

			case DELETE:

				tmpUrl = mUrl;
				if (mQuery.size() > 0)
					tmpUrl += "?" + URLEncodedUtils.format(mQuery, HTTP.UTF_8);

				HttpDelete del = new HttpDelete(tmpUrl);
				
				for (Header h : mHeaders)
					del.setHeader(h);
				
				mResponse = httpClient.execute(del);
				break;
				
			default:
				Tools.logd(TAG, "Unknown RequestType: " + mRequestType.toString() + " - execution terminated, with no callback!");
				return;
			}
			
			mStatusCode = mResponse.getStatusLine().getStatusCode();
		    mData = EntityUtils.toString(mResponse.getEntity(), HTTP.UTF_8);
			updateSessionInfo(mResponse.getAllHeaders());
			
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		} catch (ClientProtocolException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			// Close connection, to deallocate resources
			httpClient.getConnectionManager().shutdown();
		}
		
	}

	/**
	 * Method checks headers to find X-Token and X-Token-Expires.<br>
	 * If they do not exist, nothing happens as the call has a wrong endpoint, or other
	 * non-API regarding error. If they do exist, then they are checked by the Session
	 * to find out if there are any changes.
	 * @param headers to check for new token.
	 */
	private void updateSessionInfo(Header[] headers) {
		String token = null;
	    String expire = null;
	    for (Header h : headers) {
	    	if (h.getName().equals(HEADER_X_TOKEN)) {
	    		token = h.getValue();
	    	} else if (h.getName().equals(HEADER_X_TOKEN_EXPIRES)) {
	    		expire = h.getValue();
	    	}
	    }
	    if (token == null || expire == null)
	    	return;
	    
	    mEta.getSession().update(token, expire);
	}

	private void processResult() {
		
		// TODO: Check endpoint, and convert to JSONObject or JSONArray
		
		// Cache all cache able items
		
		// Further processing based on 
		
		// now process the result
		if (Tools.isSuccess(mStatusCode)) {
			if (!mCacheHit || mMultipleCallbacks) {
				convertCacheReturn(mStatusCode,mData);
			}
		
		// Error, try to get new session token, then do request again.
		} else {
			EtaError error = EtaError.fromJSON(mData);
			if ( !mSessionRefreshCall && ( (error.getCode() == 1108 || error.getCode() == 1101) ) ) {
				mSessionRefreshCall = true;
				mEta.getSession().subscribe(new SessionListener() {
					
					public void onUpdate() {
						mEta.getSession().unSubscribe(this);
						runThread();
					}
				}).update();
			} else {
				runOnUiThread(mStatusCode, null, error);
			}
		}
		
	}
	
	private void convertCacheReturn(int statusCode, String data) {
		
		EtaError er = null;
		if (mListener instanceof Api.CallbackCatalogList) {
			ArrayList<Catalog> cs = Catalog.fromJSONArray(data);
			er = cs.size() > 0 ? null : (EtaError.fromJSON(data));
			runOnUiThread(statusCode, cs, er);
			return;
			
		} else if  (mListener instanceof Api.CallbackOfferList) {
			ArrayList<Offer> os = Offer.fromJSONArray(data);
			er = os.size() > 0 ? null : (EtaError.fromJSON(data));
			runOnUiThread(statusCode, os, er);
			return;
			
		} else if  (mListener instanceof Api.CallbackOffer) {
			Offer o = Offer.fromJSON(data);
			if (o.getId() == null) {
				er = EtaError.fromJSON(data);
			} else {
				mEta.getCache().put(o.getErn(), o, statusCode);
			}
			runOnUiThread(statusCode, o, er);
			return;
			
		} else if  (mListener instanceof Api.CallbackCatalog) {
			Catalog c = Catalog.fromJSON(data.toString());
			if (c.getId() == null) {
				er = EtaError.fromJSON(data);
			} else {
				mEta.getCache().put(c.getErn(), c, statusCode);
			}
			runOnUiThread(statusCode, c, er);
			return;
			
		} else if  (mListener instanceof Api.CallbackDealerList) {
			ArrayList<Dealer> ds = Dealer.fromJSONArray(data);
			er = ds.size() > 0 ? null : (EtaError.fromJSON(data));
			runOnUiThread(statusCode, ds, er);
			return;
			
		} else if  (mListener instanceof Api.CallbackStoreList) {
			ArrayList<Store> ss = Store.fromJSONArray(data);
			er = ss.size() > 0 ? null : (EtaError.fromJSON(data));
			runOnUiThread(statusCode, ss, er);
			return;

		} else if  (mListener instanceof Api.CallbackDealer) {
			Dealer d = Dealer.fromJSON(data);
			if (d.getId() == null) {
				er = EtaError.fromJSON(data);
			} else {
				mEta.getCache().put(d.getErn(), d, statusCode);
			}
			runOnUiThread(statusCode, d, er);
			return;
			
		} else if  (mListener instanceof Api.CallbackStore) {
			Store s = Store.fromJSON(data);
			if (s.getId() == null) {
				er = EtaError.fromJSON(data);
			} else {
				mEta.getCache().put(s.getErn(), s, statusCode);
			}
			runOnUiThread(statusCode, s, er);
			return;
			
		} else if (mListener instanceof Api.CallbackString) {
			runOnUiThread(mStatusCode, data, er);
			return;	
		}
		
	}
	
	private void runOnUiThread(final int statusCode,final Object data,final EtaError error) {
		mEta.getHandler().post(new Runnable() {
			
			@SuppressWarnings("unchecked")
			public void run() {
				if (!isCanceled())
					mListener.onComplete(statusCode, data, error);
			}
		});
	}

	private void printDebugPreExecute() {

		if (mPrintDebug) {
			StringBuilder sb = new StringBuilder();
			sb.append("*** Pre Execute: ").append(getClass().getSimpleName()).append("@").append(Integer.toHexString(hashCode())).append(" : ")
			.append("Url[").append(mUrl).append("], ")
			.append("Query[");
			for (NameValuePair nvp : mQuery)
				sb.append(nvp.getName()).append(": ").append(nvp.getValue()).append(", ");
				
			sb.append("], ")
			.append("Type[").append(mRequestType.toString()).append("], ")
			.append("Headers[").append(mHeaders.toString()).append("], ");
			
			Tools.logd(TAG, sb.toString());
		}
		
	}
	
	private void printDebugPostExecute() {

	    if (mPrintDebug) {

			StringBuilder sb = new StringBuilder();
			sb.append("*** Post Execute: ").append(getClass().getSimpleName()).append("@").append(Integer.toHexString(hashCode())).append(" : ")
			.append("StatusCode[").append(mStatusCode).append("], ")
			.append("Headers[");
			for (Header h : mResponse.getAllHeaders())
				sb.append(h.getName()).append(": ").append(h.getValue()).append(", ");
				
			sb.append("], ")
			.append("Object[").append( mData.length() < 100 ? mData : mData.substring(0, 99) ).append("], ");
			Tools.logd(TAG, sb.toString());
	    	
	    }
	    
	}
	
	public static interface Callback<T> {
		public void onComplete(int statusCode, T data, EtaError error);
	}
	
    /** Standard callback interface for API requests */
    public static interface CallbackString extends Callback<String>{
		public void onComplete(int statusCode, String data, EtaError error);
    }

    /** Callback interface for a list of catalogs*/
    public static interface CallbackCatalogList extends Callback<List<Catalog>> {
    	public void onComplete(int statusCode, List<Catalog> catalogs, EtaError error);
    }

    /** Callback interface for a list of offers */
    public static interface CallbackOfferList extends Callback<List<Offer>> {
        public void onComplete(int statusCode, List<Offer> offers, EtaError error);
    }

    /** Callback interface for a list of dealers */
    public static interface CallbackDealerList extends Callback<List<Dealer>> {
        public void onComplete(int statusCode, List<Dealer> dealers, EtaError error);
    }

    /** Callback interface for a list of stores */
    public static interface CallbackStoreList extends Callback<List<Store>> {
        public void onComplete(int statusCode, List<Store> stores, EtaError error);
    }

    /** Callback interface for a single catalog */
    public static interface CallbackCatalog extends Callback<Catalog> {
        public void onComplete(int statusCode, Catalog catalog, EtaError error);
    }

    /** Callback interface for a single offer */
    public static interface CallbackOffer extends Callback<Offer> {
        public void onComplete(int statusCode, Offer offer, EtaError error);
    }

    /** Callback interface for a single dealer */
    public static interface CallbackDealer extends Callback<Dealer> {
        public void onComplete(int statusCode, Dealer dealer, EtaError error);
    }

    /** Callback interface for a single store */
    public static interface CallbackStore extends Callback<Store> {
        public void onComplete(int statusCode, Store store, EtaError error);
    }
    
}
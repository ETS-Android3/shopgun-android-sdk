/**
 * @fileoverview	API.
 * @author			Danny Hvam <danny@etilbudsavis.dk>
 */
package com.eTilbudsavis.etasdk;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

import org.apache.http.Header;
import org.apache.http.NameValuePair;
import org.apache.http.message.BasicHeader;

import Utils.Endpoint;
import Utils.Params;
import Utils.Sort;
import Utils.Utilities;
import android.os.Bundle;
import android.os.Looper;
import android.text.TextUtils;

import com.eTilbudsavis.etasdk.EtaCache.CacheItem;
import com.eTilbudsavis.etasdk.HttpHelper.HttpListener;
import com.eTilbudsavis.etasdk.Session.SessionListener;
import com.eTilbudsavis.etasdk.EtaObjects.Catalog;
import com.eTilbudsavis.etasdk.EtaObjects.Dealer;
import com.eTilbudsavis.etasdk.EtaObjects.EtaError;
import com.eTilbudsavis.etasdk.EtaObjects.Offer;
import com.eTilbudsavis.etasdk.EtaObjects.Store;

public class Api implements Serializable {
	
	private static final long serialVersionUID = 1L;
	
	public static final String TAG = "Api";
	
	public static final String API_KEY = Params.API_KEY;
	
	/** Header name for the session token */
	public static final String HEADER_X_TOKEN = Params.HEADER_X_TOKEN;
	
	/** Header name for the signature generated by the app */
	public static final String HEADER_X_SIGNATURE = Params.HEADER_X_SIGNATURE;
	
	public static final String HEADER_CONTENT_TYPE = Params.HEADER_CONTENT_TYPE;
	
	/** The default page limit for API calls */
	public static final int DEFAULT_OFFSET = Params.DEFAULT_OFFSET;

	/** The default page limit for API calls */
	public static final int DEFAULT_LIMIT = Params.DEFAULT_LIMIT;
	
	/**
	 * Expected return type. Default is JSON.<br><br>
	 * <i>Other types are not implemented yet.</i><br>
	 * TODO: Complete implementation
	 */
	public enum AcceptType {
		XML		{ public String toString() { return "application/xml, text/xml"; } },
		CSV		{ public String toString() { return "application/csv"; } },
		JSON	{ public String toString() { return "application/json"; } }
	}
	
	/**
	 * Type of HTTP request.<br><br>
	 * <i>OPTIONS and HEAD are not implemented yet.</i><br>
	 * TODO: Complete implementation
	 */
	public enum RequestType {
		POST, GET, PUT, DELETE, OPTIONS, HEAD
	}
	
	/**
	 * Content-Type used in request. Default is URLENCODED<br><br>
	 * <i>Other types are not implemented yet.</i><br>
	 * TODO: Complete implementation
	 */
	public enum ContentType {
		JSON			{ public String toString() { return "application/json; charset=utf-8"; } },
		URLENCODED	{ public String toString() { return "application/x-www-form-urlencoded; charset=utf-8"; } },
		FORMDATA		{ public String toString() { return "multipart/form-data; charset=utf-8"; } }
	}

	private Eta mEta;
	private String mUrl = null;
	// Due to cache, this has to be a raw type for now
	private Callback mListener = null;
	private Bundle mApiParams = null;
	private RequestType mRequestType = null;
	private ContentType mContentType = null;
	private HashMap<String, String> mHeaders;
	private String mId = null;
	private boolean mSessionRefreshCall = false;
	private boolean mCacheHit = false;
	private boolean mMultipleCallbacks = false;
	
	private HttpHelper httpHelper;
	private boolean mUseLocation = true;
	private boolean mUseCache = true;
	private boolean mUseDebug = false;
	private HttpListener mHttpListener = new HttpListener() {

		public void onComplete(int statusCode, String data, Header[] headers) {
			
			// Success
			if (200 <= statusCode && statusCode < 300) {
				if (!mCacheHit || mMultipleCallbacks)
				convertCacheReturn(statusCode,data);
			
			// Error, try to get new session token, then do request again.
			} else {
				EtaError error = EtaError.fromJSON(data);
				if ( !mSessionRefreshCall && ( (error.getCode() == 1108 || error.getCode() == 1101) ) ) {
					mSessionRefreshCall = true;
					mEta.getSession().subscribe(new SessionListener() {
						
						public void onUpdate() {
							mEta.getSession().unSubscribe(this);
							completeExecute();
						}
					}).update();
				} else {
					mListener.onComplete(statusCode, null, error);
				}
			}
		}
	};

	private void convertCacheReturn(int statusCode, String data) {
		
		EtaError er = null;
		
		if (mListener instanceof Api.CallbackCatalogList) {
			ArrayList<Catalog> cs = Catalog.fromJSONArray(data);
			er = cs.size() > 0 ? null : (EtaError.fromJSON(data));
			((CallbackCatalogList)mListener).onComplete(statusCode, cs, er);
			return;
			
		} else if  (mListener instanceof Api.CallbackOfferList) {
			ArrayList<Offer> os = Offer.fromJSONArray(data);
			er = os.size() > 0 ? null : (EtaError.fromJSON(data));
			((CallbackOfferList)mListener).onComplete(statusCode, os, er);
			return;
			
		} else if  (mListener instanceof Api.CallbackOffer) {
			Offer o = Offer.fromJSON(data);
			if (o.getId() == null) {
				er = EtaError.fromJSON(data);
			} else {
				mEta.getCache().put(o.getErn(), o, statusCode);
			}
			((CallbackOffer)mListener).onComplete(statusCode, o, er);
			return;
			
		} else if  (mListener instanceof Api.CallbackCatalog) {
			Catalog c = Catalog.fromJSON(data.toString());
			if (c.getId() == null) {
				er = EtaError.fromJSON(data);
			} else {
				mEta.getCache().put(c.getErn(), c, statusCode);
			}
			((CallbackCatalog)mListener).onComplete(statusCode, c, er);
			return;
			
		} else if  (mListener instanceof Api.CallbackDealerList) {
			ArrayList<Dealer> ds = Dealer.fromJSONArray(data);
			er = ds.size() > 0 ? null : (EtaError.fromJSON(data));
			((CallbackDealerList)mListener).onComplete(statusCode, ds, er);
			return;
			
		} else if  (mListener instanceof Api.CallbackStoreList) {
			ArrayList<Store> ss = Store.fromJSONArray(data);
			er = ss.size() > 0 ? null : (EtaError.fromJSON(data));
			((CallbackStoreList)mListener).onComplete(statusCode, ss, er);
			return;

		} else if  (mListener instanceof Api.CallbackDealer) {
			Dealer d = Dealer.fromJSON(data);
			if (d.getId() == null) {
				er = EtaError.fromJSON(data);
			} else {
				mEta.getCache().put(d.getErn(), d, statusCode);
			}
			((CallbackDealer)mListener).onComplete(statusCode, d, er);
			return;
			
		} else if  (mListener instanceof Api.CallbackStore) {
			Store s = Store.fromJSON(data);
			if (s.getId() == null) {
				er = EtaError.fromJSON(data);
			} else {
				mEta.getCache().put(s.getErn(), s, statusCode);
			}
			((CallbackStore)mListener).onComplete(statusCode, s, er);
			return;
			
		} else if (mListener instanceof Api.CallbackString) {
			((CallbackString)mListener).onComplete(statusCode, data, er);		
			return;	
		}
		
	}

	/**
	 * TODO: Write proper JavaDoc<br>
	 * <code>new String[] {Api.SORT_DISTANCE, Api.SORT_PUBLISHED}</code>
	 * @param order
	 * @return This {@link com.eTilbudsavis.etasdk.Api Api} object to allow for chaining of calls to set methods
	 */
	public Api setOrderBy(String order) {
		mApiParams.putString(Sort.ORDER_BY, order);
		return this;
	}

	public Api setOrderBy(String[] order) {
		String tmp = TextUtils.join(",",order);
		mApiParams.putString(Sort.ORDER_BY, tmp);
		return this;
	}
	
	public String getOrderBy() {
		return mApiParams.getString(Sort.ORDER_BY);
	}

	/**
	 * Sets a list of id's to filter result by.
	 * @param id's to filter by
	 * @return this object
	 */
	public Api setCatalogIds(String[] ids) {
		applyFilter(Params.FILTER_CATALOG_IDS, ids);
		return this;
	}

	/**
	 * Returns a list of id's that this {@link com.eTilbudsavis.etasdk.Api Api} will filter results by.
	 * @return a list if id's
	 */
	public String[] getCatalogIds() {
		return getFilter(Params.FILTER_CATALOG_IDS);
	}

	/**
	 * Sets a list of id's to filter result by.
	 * @param id's to filter by
	 * @return this object
	 */
	public Api setDealerIds(String[] ids) {
		applyFilter(Params.FILTER_DEALER_IDS, ids);
		return this;
	}

	/**
	 * Returns a list of id's that this {@link com.eTilbudsavis.etasdk.Api Api} will filter results by.
	 * @return a list if id's
	 */
	public String[] getDealerIds() {
		return getFilter(Params.FILTER_DEALER_IDS);
	}

	/**
	 * Sets a list of id's to filter result by.
	 * @param id's to filter by
	 * @return this object
	 */
	public Api setStoreIds(String[] ids) {
		applyFilter(Params.FILTER_STORE_IDS, ids);
		return this;
	}

	/**
	 * Returns a list of id's that this {@link com.eTilbudsavis.etasdk.Api Api} will filter results by.
	 * @return a list if id's
	 */
	public String[] getStoreIds() {
		return getFilter(Params.FILTER_STORE_IDS);
	}

	/**
	 * Sets a list of id's to filter result by.
	 * @param id's to filter by
	 * @return this object
	 */
	public Api setOfferIds(String[] ids) {
		applyFilter(Params.FILTER_OFFER_IDS, ids);
		return this;
	}

	/**
	 * Returns a list of id's that this {@link com.eTilbudsavis.etasdk.Api Api} will filter results by.
	 * @return a list if id's
	 */
	public String[] getOfferIds() {
		return getFilter(Params.FILTER_OFFER_IDS);
	}

	/**
	 * Sets a list of id's to filter result by.
	 * @param ids to filter by
	 * @return this object
	 */
	public Api setAreaIds(String[] ids) {
		applyFilter(Params.FILTER_AREA_IDS, ids);
		return this;
	}

	/**
	 * Returns a list of id's that this {@link com.eTilbudsavis.etasdk.Api Api} will filter results by.
	 * @return a list if id's
	 */
	public String[] getAreaIds() {
		return getFilter(Params.FILTER_AREA_IDS);
	}
	
	/**
	 * Set a parameter for what specific id's to get from a given endpoint.<br><br>
	 * 
	 * E.g.: setIds(Catalog.PARAM_IDS, new String[]{"eecdA5g","b4Aea5h"});
	 * @param	filterName of the endpoint parameter e.g. Catalog.PARAM_IDS
	 * @param	ids to filter by
	 * @return	this object
	 */
	public Api applyFilter(String filterName, String[] ids) {
		String tmp = TextUtils.join(",",ids);
		mApiParams.putString(filterName, tmp);
		return this;
	}
	
	public Api removeFilter(String filterName) {
		mApiParams.remove(filterName);
		return this;
	}
	
	/**
	 * Returns a list of id's that this {@link com.eTilbudsavis.etasdk.Api Api} will filter results by.
	 * @param	filterName 
	 * @return	a list if id's
	 */
	public String[] getFilter(String filterName) {
		String tmp = mApiParams.getString(filterName);
		return TextUtils.split(tmp, ",");
	}
	
	/**
	 * Set a parameter for what specific id to get from a given endpoint.<br><br>
	 * 
	 * E.g.: setIds(Catalog.PARAM_IDS, "b4Aea5h");
	 * @param id to filter by
	 * @return this object
	 */
	public Api setId(String id) {
		mId = id;
		return this;
	}
	
	public String getId() {
		return mId;
	}
	
	public Api setContentType(ContentType type) {
		mContentType = type;
		return this;
	}

	public ContentType getContentType() {
		return mContentType;
	}

	public Api setRequestType(RequestType type) {
		mRequestType = type;
		return this;
	}

	public RequestType getRequestType() {
		return mRequestType;
	}

	public Bundle getApiParameters() {
		return mApiParams;
	}

	public Api setApiParameters(Bundle params) {
		mApiParams = params;
		return this;
	}

	public String getUrl() {
		return mUrl;
	}

	public Api setUrl(String url) {
		mUrl = url;
		return this;
	}

	public Callback<?> getListener() {
		return mListener;
	}

	public Api setListener(CallbackString listener) {
		mListener = listener;
		return this;
	}
	
	/**
	 * Set any headers that you want in this API call. This should not generally
	 * be used, as the SDK handles all headers.
	 * @param name the name of the header.
	 * @param value the value of the header.
	 * @return This {@link com.eTilbudsavis.etasdk.Api Api} object to allow for chaining of calls to set methods
	 */
	public Api setHeader(String name, String value) {
		mHeaders.put(name, value);
		return this;
	}
	
	/**
	 * Get a list of the headers that this API call will send to server.<br>
	 * <b>Note</b> that X-Token a X-Signature is not included in this bundle.
	 * @return List of headers.
	 */
	public HashMap<String, String> getHeaders() {
		return mHeaders;
	}

	public Api setUseCache(boolean useCache) {
		mUseCache = useCache;
		return this;
	}
	
	public boolean useCache() {
		return mUseCache;
	}
	
	/**
	 * 
	 * @param multipleCallbacks
	 * @return
	 */
	public Api setMultipleCallbacks(boolean multipleCallbacks) {
		mMultipleCallbacks = multipleCallbacks;
		return this;
	}
	
	public boolean useMultipleCallbacks() {
		return mMultipleCallbacks = false;
	}

	/**
	 * Whether to use location for this API call
	 * @param useLocation
	 * @return
	 */
	public Api setUseLocation(boolean useLocation) {
		this.mUseLocation = useLocation;
		return this;
	}

	/**
	 * Determine whether location is being used, for this API call
	 * @return True if location is being used, false otherwise.
	 */
	public boolean useLocation() {
		return mUseLocation;
	}

	/**
	 * Whether to print debug information to LogCat.<br><br>
	 * Prints URL, query and headers before execute. <br>
	 * And prints return headers, and the raw date of the reply.
	 * @param useDebug
	 * @return this object
	 */
	public Api setDebug(boolean useDebug) {
		this.mUseDebug = useDebug;
		return this;
	}

	/**
	 * Tells whether the current {@link com.etilbudsavis.etasdk.API Api()} is printing debug information
	 */
	public boolean useDebug() {
		return mUseDebug;
	}
	
	/**
	 * Default constructor for API
	 * @param Eta object with relevant information e.g. location
	 */
	public Api(Eta eta) {
		mEta = eta;
	}

	public Api search(String url, Callback<?> listener, String query) {
		if (!url.matches(Endpoint.SEARCH))
			Utilities.logd(TAG, "url does not match a search endpoint, don't expect anything good...");
		
		Bundle apiParams = new Bundle();
		apiParams.putString(Params.QUERY, query);
		return request(url, listener, apiParams, RequestType.GET, ContentType.URLENCODED, null);
	}

	public Api get(String url, Callback<?> listener) {
		return request(url, listener, null, RequestType.GET, ContentType.URLENCODED, null);
	}

	public Api get(String url, Callback<?> listener, Bundle apiParams) {
		return request(url, listener, apiParams, RequestType.GET, ContentType.URLENCODED, null);
	}

	public Api post(String url, Callback<?> listener, Bundle apiParams) {
		return request(url, listener, apiParams, RequestType.POST, ContentType.URLENCODED, null);
	}

	public Api delete(String url, Callback<?> listener, Bundle apiParams) {
		return request(url, listener, apiParams, RequestType.DELETE, ContentType.URLENCODED, null);
	}

	public Api put(String url, Callback<?> listener, Bundle apiParams) {
		return request(url, listener, apiParams, RequestType.PUT, ContentType.URLENCODED, null);
	}
	
	public Api request(String url, Callback<?> listener, Bundle apiParams, RequestType requestType, ContentType contentType, HashMap<String, String> headers) {
		if (url == null || listener == null || requestType == null ) {
			Utilities.logd(TAG, "Api parameters error: url, callback interface and requestType must not be null");
			return null;
		}
		
		mUrl = url;
		mListener = listener;
		mApiParams = apiParams == null ? new Bundle() : apiParams;
		mRequestType = requestType;
		mContentType = contentType == null ? ContentType.URLENCODED : contentType;
		mHeaders = headers == null ? new HashMap<String, String>(3) : headers;
		return this;
	}

	/**
	 * This will start executing the request.
	 * Note that if the {@link #request(String, CallbackString, Bundle, RequestType, Bundle) request()}'s 
	 * optionalKeys bundle contains options that have also been set by
	 * any of the Api-setters, then the setters will be used.
	 * @return HttpHelper, so execution of background task can be cancelled. <br>
	 * <b>Note</b> HttpHelper is <code>null</code> if there is no valid session. In this case
	 * {@link #execute() execute()} will try to get a valid session and then instantiate HttpHelper, here after the previous call is continued.
	 */
	public HttpHelper execute() {

		// Check if all variables needed are okay
		if (mUrl == null || mListener == null || mApiParams == null || mRequestType == null || mHeaders == null) {
			Utilities.logd(TAG, "A request() must be made before execute()");
			return null;
		}

		if (mId != null) {
			if (Endpoint.isItemEndpoint(mUrl)) {
				mUrl = mUrl + mId;
			} else {
				Utilities.logd(TAG, "Id does not match a single id endpoint, continuing without id");
			}
		}
		
		// Is Session okay? If not, check if it's a session call? If not try to make a session before continuing
		if (mEta.getSession().getToken() == null || mEta.getSession().isExpired()) {
			if (!mUrl.matches(Endpoint.SESSION)) {
				mEta.getSession().subscribe(new SessionListener() {
					
					public void onUpdate() {
						if (mEta.getSession().isExpired()) {
							mEta.getSession().unSubscribe(this);
							completeExecute();
						} else {
							mEta.getSession().update();
						}
					}
				});
				mEta.getSession().update();
			} else {
				completeExecute();
			}
		} else {
			completeExecute();
		}
		
		return httpHelper;
	}
	
	private void completeExecute() {

		// Prepare data.
		List<NameValuePair> params = new ArrayList<NameValuePair>();

		// Add optional data.
		if (!mApiParams.isEmpty()) {
			Iterator<String> iterator = mApiParams.keySet().iterator();
			while (iterator.hasNext()) {
				String s = iterator.next();
				Utilities.putNameValuePair(params, s, mApiParams.get(s));
			}
		}
		
		// Required API key.
		Utilities.putNameValuePair(params, API_KEY, mEta.getApiKey());

		if (mUseLocation) {

			if (!mEta.getLocation().isLocationSet()) {
				Utilities.logd(TAG, "Location is required, but has not been set yet. Aborting...");
				return;
			}
			EtaLocation l = mEta.getLocation();
			Utilities.putNameValuePair(params, EtaLocation.LATITUDE, l.getLatitude());
			Utilities.putNameValuePair(params, EtaLocation.LONGITUDE, l.getLongitude());
			Utilities.putNameValuePair(params, EtaLocation.SENSOR, l.getSensor());
			Utilities.putNameValuePair(params, EtaLocation.RADIUS, l.getRadius());

			// Determine whether to include bounds.
			if (mEta.getLocation().isBoundsSet()) {
				Utilities.putNameValuePair(params, EtaLocation.BOUND_EAST, l.getBoundEast());
				Utilities.putNameValuePair(params, EtaLocation.BOUND_NORTH, l.getBoundNorth());
				Utilities.putNameValuePair(params, EtaLocation.BOUND_SOUTH, l.getBoundSouth());
				Utilities.putNameValuePair(params, EtaLocation.BOUND_WEST, l.getBoundWest());
			}

		}
		
		// Set headers if session is OK
		if (mEta.getSession().getToken() != null) {
			setHeader(HEADER_X_TOKEN, mEta.getSession().getToken());
			String sha256 = Utilities.generateSHA256(mEta.getApiSecret() + mEta.getSession().getToken());
			setHeader(HEADER_X_SIGNATURE, sha256);
		}
		
		setHeader(HEADER_CONTENT_TYPE, mContentType.toString());
		
		List<Header> headers = new ArrayList<Header>();
		Iterator<String> it = mHeaders.keySet().iterator();
		while (it.hasNext()) {
			String string = (String) it.next();
			headers.add(new BasicHeader(string, mHeaders.get(string)));
		}
		
		// TODO: Check cache before executing the httpHepler
		if (mUseCache && mRequestType == RequestType.GET && mId != null) {
			String prefix = mUrl.contains(Endpoint.CATALOG_ID) ? "ern:catalog:" :
				mUrl.contains(Endpoint.DEALER_ID) ? "ern:dealer:" :
					mUrl.contains(Endpoint.STORE_ID) ? "ern:store:" : 
						mUrl.contains(Endpoint.OFFER_ID) ? "ern:offer:" : "";
			
			CacheItem c = mEta.getCache().get(prefix + mId);
			if (c != null) {
				mCacheHit = true;
				mListener.onComplete(c.statuscode, c.item, null);
			}
			
		}
		
		// Create a new HttpHelper and run it
		httpHelper = new HttpHelper(mEta, mUrl, headers, params, mRequestType, mHttpListener);
		httpHelper.debug(mUseDebug).execute();
		
	}

	public static interface Callback<T> {
		public void onComplete(int statusCode, T data, EtaError error);
	}
	
    /** Standard callback interface for API requests */
    public static interface CallbackString extends Callback<String>{
		public void onComplete(int statusCode, String data, EtaError error);
    }

    /** Callback interface for a list of catalogs*/
    public static interface CallbackCatalogList extends Callback<ArrayList<Catalog>> {
    	public void onComplete(int statusCode, ArrayList<Catalog> catalogs, EtaError error);
    }

    /** Callback interface for a list of offers */
    public static interface CallbackOfferList extends Callback<ArrayList<Offer>> {
        public void onComplete(int statusCode, ArrayList<Offer> offers, EtaError error);
    }

    /** Callback interface for a list of dealers */
    public static interface CallbackDealerList extends Callback<ArrayList<Dealer>> {
        public void onComplete(int statusCode, ArrayList<Dealer> dealers, EtaError error);
    }

    /** Callback interface for a list of stores */
    public static interface CallbackStoreList extends Callback<ArrayList<Store>> {
        public void onComplete(int statusCode, ArrayList<Store> stores, EtaError error);
    }

    /** Callback interface for a single catalog */
    public static interface CallbackCatalog extends Callback<Catalog> {
        public void onComplete(int statusCode, Catalog catalog, EtaError error);
    }

    /** Callback interface for a single offer */
    public static interface CallbackOffer extends Callback<Offer> {
        public void onComplete(int statusCode, Offer offer, EtaError error);
    }

    /** Callback interface for a single dealer */
    public static interface CallbackDealer extends Callback<Dealer> {
        public void onComplete(int statusCode, Dealer dealer, EtaError error);
    }

    /** Callback interface for a single store */
    public static interface CallbackStore extends Callback<Store> {
        public void onComplete(int statusCode, Store store, EtaError error);
    }
    
}
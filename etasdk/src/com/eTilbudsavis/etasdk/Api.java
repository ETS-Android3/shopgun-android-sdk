/**
 * @fileoverview	API.
 * @author			Danny Hvam <danny@etilbudsavis.dk>
 */
package com.eTilbudsavis.etasdk;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

import org.apache.http.Header;
import org.apache.http.NameValuePair;
import org.apache.http.message.BasicHeader;

import Utils.Endpoint;
import Utils.Sort;
import Utils.Utilities;
import android.os.Bundle;
import android.text.TextUtils;

import com.eTilbudsavis.etasdk.EtaObjects.Catalog;
import com.eTilbudsavis.etasdk.EtaObjects.Dealer;
import com.eTilbudsavis.etasdk.EtaObjects.Offer;
import com.eTilbudsavis.etasdk.EtaObjects.Store;

public class Api implements Serializable {
	
	private static final long serialVersionUID = 1L;
	public static final String TAG = "Api";
	public static final String API_KEY = "api_key";
	
	/** Header name for the session token */
	public static final String HEADER_X_TOKEN = "X-Token";
	
	/** Header name for the signature generated by the app */
	public static final String HEADER_X_SIGNATURE = "X-Signature";
	
	/** String identifying the offset parameter for all list calls to the API */
	public static final String OFFSET = "offset";
	
	/** String identifying the offset parameter for all list calls to the API */
	public static final String LIMIT = "limit";
	
	/** The default page limit for API calls */
	public static final int OFFSET_DEFAULT = 0;

	/** The default page limit for API calls */
	public static final int LIMIT_DEFAULT = 25;
	
	private Eta mEta;
	private String mUrl = null;
	private RequestListener mListener = null;
	private Bundle mParams = null;
	private RequestType mRequestType = null;
	private HashMap<String, String> mHeaders;
	
	private HttpHelper httpHelper;

	private boolean useLocation = true;
	private boolean mUseCache = true;
	
	
	/**
	 * TODO: Write proper JavaDoc<br>
	 * <code>new String[] {Api.SORT_DISTANCE, Api.SORT_PUBLISHED}</code>
	 * @param order
	 * @return This {@link com.eTilbudsavis.etasdk.Api Api} object to allow for chaining of calls to set methods
	 */
	public Api setOrderBy(String[] order) {
		mParams.putString(Sort.ORDER_BY, TextUtils.join(",", order));
		return this;
	}
	
	public String[] getOrderBy() {
		String s = mParams.getString(Sort.ORDER_BY);
		s = s == null ? "" : s;
		return TextUtils.split(s, ",");
	}
	
	/**
	 * Set any headers that you want in this API call. This should not generally
	 * be used, as the SDK handles all headers.
	 * @param name the name of the header.
	 * @param value the value of the header.
	 * @return This {@link com.eTilbudsavis.etasdk.Api Api} object to allow for chaining of calls to set methods
	 */
	public Api setHeader(String name, String value) {
		mHeaders.put(name, value);
		return this;
	}
	
	/**
	 * Get a list of the headers that this API call will send to server.<br>
	 * <b>Note</b> that X-Token a X-Signature is not included in this bundle.
	 * @return List of headers.
	 */
	public HashMap<String, String> getHeaders() {
		return mHeaders;
	}
	
	/**
	 * The type expected to return;
	 * Default is JSON, other types are not implemented yet
	 */
	public enum AcceptType {
		XML { public String toString() { return "application/xml, text/xml"; } },
		CSV { public String toString() { return "application/csv"; } },
		JSON { public String toString() { return "application/json"; } }
	}
	
	public enum RequestType {
		HEAD, POST, GET, PUT, DELETE, OPTIONS
	}
	
	/**
	 * The content type to use in requests. This feature is not implemented yet.
	 */
	public enum ContentType {
		JSON { public String toString() { return "application/json; charset=utf-8"; } },
		URLENCODED { public String toString() { return "application/x-www-form-urlencoded; charset=utf-8"; } },
		FORMDATA { public String toString() { return "multipart/form-data; charset=utf-8"; } }
	}
	
	public Api setUseCache(boolean useCache) {
		mUseCache = useCache;
		return this;
	}
	
	public boolean useCache() {
		return mUseCache;
	}
	
	/**
	 * Tell, whether to use location for this API call
	 * @param useLocation
	 * @return
	 */
	public Api setUseLocation(boolean useLocation) {
		this.useLocation = useLocation;
		return this;
	}

	/**
	 * Determine whether location is being used, for this API call
	 * @return True if location is being used, false otherwise.
	 */
	public boolean useLocation() {
		return useLocation;
	}
	
	/**
	 * Default constructor for API
	 * @param Eta object with relevant information e.g. location
	 */
	public Api(Eta eta) {
		mEta = eta;
	}
	
	public Api build(String url, RequestListener requestListener) {
		return build(url, requestListener, new Bundle());
	}

	public Api build(String url, RequestListener requestListener, Bundle apiParams) {
		return build(url, requestListener, apiParams, Api.RequestType.GET);
	}

	public Api build(String url, RequestListener requestListener, RequestType requestType) {
		return build(url, requestListener, new Bundle(), requestType, new HashMap<String, String>(2));
	}

	public Api build(String url, RequestListener requestListener, Bundle apiParams, RequestType requestType) {
		return build(url, requestListener, apiParams, requestType, new HashMap<String, String>(2));
	}

	/**
	 * 
	 *
	 * @param url - This can be any URL, but optionalKeys are only sent if the URL points to the ETA API
	 * @param requestListener - API.RequestListener
	 * @param apiParams - Bundle containing parameters specified on https://etilbudsavis.dk/developers/docs/
	 * @param requestType - API.RequestType
	 */
	public Api build(String url, RequestListener requestListener, Bundle apiParams, RequestType requestType, HashMap<String, String> headers) {
		if (url == null || requestListener == null || requestType == null ) {
			Utilities.logd(TAG, "Api parameters error: url, requestListener and requestType cannot be null");
			return null;
		} 
		mUrl = url;
		mListener = requestListener;
		mParams = apiParams == null ? new Bundle() : apiParams;
		mRequestType = requestType;
		mHeaders = headers == null ? new HashMap<String, String>(2) : headers;
		return this;
	}

	/**
	 * This will start executing the request.
	 * Note that if the {@link #build(String, RequestListener, Bundle, RequestType, Bundle) request()}'s 
	 * optionalKeys bundle contains options that have also been set by
	 * any of the Api-setters, then the setters will be used.
	 * @return HttpHelper, so execution of background task can be cancelled. <br>
	 * <b>Note</b> HttpHelper is <code>null</code> if there is no valid session. In this case
	 * {@link #execute() execute()} will try to get a valid session and then instantiate HttpHelper, here after the previous call is continued.
	 */
	public HttpHelper execute() {

		// Check if all variables needed are okay
		if (mUrl == null || mListener == null || mParams == null || mRequestType == null || mHeaders == null) {
			Utilities.logd(TAG, "A request() must be made before execute()");
			return null;
		}
		
		// Check if RequestListener matches the URL (return values are parsed according to RequestListener)
		if (!listenerMatchesUrl()) {
			Utilities.logd(TAG, "Choosen listener - " + mListener.getClass().getName() + " - does not match endpoint - " + mUrl);
			return null;
		}
		
		// Is Session okay? If not, check if it's a session call? If not try to make a session before continuing
		if (mEta.getSession().getToken() == null || mEta.getSession().getExpire() < System.currentTimeMillis()) {
			if (!mUrl.matches(Endpoint.SESSION)) {
				mEta.updateSession(new RequestListener() {
					
					public void onComplete(int responseCode, Object object) {
						if (responseCode == 201)
							completeExecute();
					}
				});
			} else {
				completeExecute();
			}
		} else {
			completeExecute();
		}
		
		return httpHelper;
	}
	
	private void completeExecute() {

		// Prefix URL?
		if (!mUrl.matches("^http.*"))
			mUrl = Endpoint.API + mUrl;
		
		// Prepare data.
		List<NameValuePair> params = new ArrayList<NameValuePair>();

		// Add optional data.
		if (!mParams.isEmpty()) {
			Iterator<String> iterator = mParams.keySet().iterator();
			while (iterator.hasNext()) {
				String s = iterator.next();
				Utilities.putNameValuePair(params, s, mParams.get(s));
			}
		}

		// Required API key.
		Utilities.putNameValuePair(params, API_KEY, mEta.getApiKey());

		if (useLocation) {

			if (!mEta.getLocation().isLocationSet()) {
				Utilities.logd(TAG, "Location has not been set() yet... Aborting...");
				return;
			}
			EtaLocation l = mEta.getLocation();
			Utilities.putNameValuePair(params, EtaLocation.LATITUDE, l.getLatitude());
			Utilities.putNameValuePair(params, EtaLocation.LONGITUDE, l.getLongitude());
			Utilities.putNameValuePair(params, EtaLocation.SENSOR, l.getSensor());
			Utilities.putNameValuePair(params, EtaLocation.RADIUS, l.getRadius());

			// Determine whether to include bounds.
			if (mEta.getLocation().isBoundsSet()) {
				Utilities.putNameValuePair(params, EtaLocation.BOUND_EAST, l.getBoundEast());
				Utilities.putNameValuePair(params, EtaLocation.BOUND_NORTH, l.getBoundNorth());
				Utilities.putNameValuePair(params, EtaLocation.BOUND_SOUTH, l.getBoundSouth());
				Utilities.putNameValuePair(params, EtaLocation.BOUND_WEST, l.getBoundWest());
			}

		}
		
		// Set headers if session is OK
		if (mEta.getSession().getToken() != null) {
			setHeader(HEADER_X_TOKEN, mEta.getSession().getToken());
			String sha256 = Utilities.generateSHA256(mEta.getApiSecret() + mEta.getSession().getToken());
			setHeader(HEADER_X_SIGNATURE, sha256);
		}
		
		List<Header> headers = new ArrayList<Header>();
		Iterator<String> it = mHeaders.keySet().iterator();
		while (it.hasNext()) {
			String string = (String) it.next();
			headers.add(new BasicHeader(string, mHeaders.get(string)));
		}
		
		// TODO: Check cache before executing the httpHepler
		if (mUseCache) {
			
		} else {

		}
		
		// Create a new HttpHelper and run it
		httpHelper = new HttpHelper(mEta, mUrl, params, headers, mRequestType, mListener);
		httpHelper.execute();
	}
	
	public boolean listenerMatchesUrl() {
		if (mListener instanceof CatalogListener) {
			return mUrl.matches(Endpoint.CATALOG_ID) ? true : false;
		} else if (mListener instanceof CatalogsListener) {
			return ( mUrl.matches(Endpoint.CATALOG_IDS) ||
					 mUrl.matches(Endpoint.CATALOG_LIST) ||
					 mUrl.matches(Endpoint.CATALOG_SEARCH)) ? true : false;
		} else if (mListener instanceof OfferListener) {
			return mUrl.matches(Endpoint.OFFER_ID) ? true : false;
		} else if (mListener instanceof OffersListener) {
			return ( mUrl.matches(Endpoint.OFFER_IDS) ||
					 mUrl.matches(Endpoint.OFFER_LIST) ||
					 mUrl.matches(Endpoint.OFFER_SEARCH)) ? true : false;
		} else if (mListener instanceof DealerListener) {
			return mUrl.matches(Endpoint.DEALER_ID) ? true : false;
		} else if (mListener instanceof DealersListener) {
			return ( mUrl.matches(Endpoint.DEALER_IDS) ||
					 mUrl.matches(Endpoint.DEALER_LIST) ||
					 mUrl.matches(Endpoint.DEALER_SEARCH)) ? true : false;
		} else if (mListener instanceof StoreListener) {
			return mUrl.matches(Endpoint.STORE_ID) ? true : false;
		} else if (mListener instanceof StoresListener) {
			return ( mUrl.matches(Endpoint.STORE_IDS) ||
					 mUrl.matches(Endpoint.STORE_LIST) ||
					 mUrl.matches(Endpoint.STORE_SEARCH)) ? true : false;
		} else if (mListener instanceof RequestListener) {
			return true;
		}
		return false;
	}

    /** Callback interface for API requests */
    public static interface RequestListener {
        public void onComplete(int responseCode, Object object);
    }

    /** Callback interface for a list of catalogs */
    public static interface CatalogsListener extends RequestListener {
        public void onComplete(int responseCode, ArrayList<Catalog> catalogs);
    }

    /** Callback interface for a list of offers */
    public static interface OffersListener extends RequestListener {
        public void onComplete(int responseCode, ArrayList<Offer> offers);
    }

    /** Callback interface for a list of dealers */
    public static interface DealersListener extends RequestListener {
        public void onComplete(int responseCode, ArrayList<Dealer> dealers);
    }

    /** Callback interface for a list of stores */
    public static interface StoresListener extends RequestListener {
        public void onComplete(int responseCode, ArrayList<Store> stores);
    }

    /** Callback interface for a single catalog */
    public static interface CatalogListener extends RequestListener {
        public void onComplete(int responseCode, Catalog catalog);
    }

    /** Callback interface for a single offer */
    public static interface OfferListener extends RequestListener {
        public void onComplete(int responseCode, Offer offer);
    }

    /** Callback interface for a single dealer */
    public static interface DealerListener extends RequestListener {
        public void onComplete(int responseCode, Dealer dealer);
    }

    /** Callback interface for a single store */
    public static interface StoreListener extends RequestListener {
        public void onComplete(int responseCode, Store store);
    }
    
}
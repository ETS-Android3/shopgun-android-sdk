/**
 * @fileoverview	API.
 * @author			Danny Hvam <danny@etilbudsavis.dk>
 */
package com.eTilbudsavis.etasdk;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

import org.apache.http.Header;
import org.apache.http.NameValuePair;
import org.apache.http.message.BasicHeader;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import Utils.Endpoint;
import Utils.Params;
import Utils.Sort;
import Utils.Utilities;
import android.os.Bundle;
import android.text.TextUtils;

import com.eTilbudsavis.etasdk.EtaObjects.Catalog;
import com.eTilbudsavis.etasdk.EtaObjects.Dealer;
import com.eTilbudsavis.etasdk.EtaObjects.EtaError;
import com.eTilbudsavis.etasdk.EtaObjects.Offer;
import com.eTilbudsavis.etasdk.EtaObjects.Store;
import com.eTilbudsavis.etasdk.EtaObjects.Session.SessionListener;

public class Api implements Serializable {
	
	private static final long serialVersionUID = 1L;
	
	public static final String TAG = "Api";
	
	public static final String API_KEY = Params.API_KEY;
	
	/** Header name for the session token */
	public static final String HEADER_X_TOKEN = Params.HEADER_X_TOKEN;
	
	/** Header name for the signature generated by the app */
	public static final String HEADER_X_SIGNATURE = Params.HEADER_X_SIGNATURE;
	
	public static final String HEADER_CONTENT_TYPE = Params.HEADER_CONTENT_TYPE;
	
	/** String identifying the offset parameter for all list calls to the API */
	public static final String OFFSET = Params.OFFSET;
	
	/** String identifying the offset parameter for all list calls to the API */
	public static final String LIMIT = Params.LIMIT;
	
	/** The default page limit for API calls */
	public static final int DEFAULT_OFFSET = Params.DEFAULT_OFFSET;

	/** The default page limit for API calls */
	public static final int DEFAULT_LIMIT = Params.DEFAULT_LIMIT;
	
	/**
	 * Expected return type. Default is JSON.<br><br>
	 * <i>Other types are not implemented yet.</i><br>
	 * TODO: Complete implementation
	 */
	public enum AcceptType {
		XML		{ public String toString() { return "application/xml, text/xml"; } },
		CSV		{ public String toString() { return "application/csv"; } },
		JSON	{ public String toString() { return "application/json"; } }
	}
	
	/**
	 * Type of HTTP request.<br><br>
	 * <i>OPTIONS and HEAD are not implemented yet.</i><br>
	 * TODO: Complete implementation
	 */
	public enum RequestType {
		POST, GET, PUT, DELETE, OPTIONS, HEAD
	}
	
	/**
	 * Content-Type used in request. Default is URLENCODED<br><br>
	 * <i>Other types are not implemented yet.</i><br>
	 * TODO: Complete implementation
	 */
	public enum ContentType {
		JSON			{ public String toString() { return "application/json; charset=utf-8"; } },
		URLENCODED	{ public String toString() { return "application/x-www-form-urlencoded; charset=utf-8"; } },
		FORMDATA		{ public String toString() { return "multipart/form-data; charset=utf-8"; } }
	}

	private Eta mEta;
	private String mUrl = null;
	private RequestListener mListenerUser = null;
	private Bundle mParams = null;
	private RequestType mRequestType = null;
	private ContentType mContentType = null;
	private HashMap<String, String> mHeaders;
	
	private HttpHelper httpHelper;

	private boolean useLocation = true;
	private boolean mUseCache = true;
	
	private RequestListener mListenerApi = new RequestListener() {

		public void onComplete(int statusCode, Object object) {

			// Success
			if (200 <= statusCode && statusCode < 300) {
				doCallback(statusCode, object);
				
			// Error
			} else if (400 <= statusCode && statusCode < 500) {
				
				// If it's a Session problem, refresh Session and retry
				EtaError e = (EtaError)object;
				if ( (e.getCode() == 1108 || e.getCode() == 1101) ) {
					mEta.getSession().subscribe(new SessionListener() {
						
						public void onUpdate() {
							mEta.getSession().unSubscribe(this);
							completeExecute();
						}
					}).update();
				} else {
					mListenerUser.onComplete(statusCode, object);
				}
			
			// Random
			} else {
				mListenerUser.onComplete(statusCode, object);
			}
		}
	};

	/**
	 * TODO: Write proper JavaDoc<br>
	 * <code>new String[] {Api.SORT_DISTANCE, Api.SORT_PUBLISHED}</code>
	 * @param order
	 * @return This {@link com.eTilbudsavis.etasdk.Api Api} object to allow for chaining of calls to set methods
	 */
	public Api setOrderBy(String order) {
		mParams.putString(Sort.ORDER_BY, order);
		return this;
	}

	public Api setOrderBy(String[] order) {
		mParams.putString(Sort.ORDER_BY, TextUtils.join(",",order));
		return this;
	}
	
	public String getOrderBy() {
		String s = mParams.getString(Sort.ORDER_BY);
		s = s == null ? "" : s;
		return s;
	}

	public Api setContentType(ContentType type) {
		mContentType = type;
		return this;
	}

	public ContentType getContentType() {
		return mContentType;
	}

	public Api setRequestType(RequestType type) {
		mRequestType = type;
		return this;
	}

	public RequestType getRequestType() {
		return mRequestType;
	}

	public Bundle getApiParameters() {
		return mParams;
	}

	public Api setApiParameters(Bundle params) {
		mParams = params;
		return this;
	}

	public String getUrl() {
		return mUrl;
	}

	public Api setUrl(String url) {
		mUrl = url;
		return this;
	}

	public RequestListener getListener() {
		return mListenerUser;
	}

	public Api setListener(RequestListener listener) {
		mListenerUser = listener;
		return this;
	}
	
	/**
	 * Set any headers that you want in this API call. This should not generally
	 * be used, as the SDK handles all headers.
	 * @param name the name of the header.
	 * @param value the value of the header.
	 * @return This {@link com.eTilbudsavis.etasdk.Api Api} object to allow for chaining of calls to set methods
	 */
	public Api setHeader(String name, String value) {
		mHeaders.put(name, value);
		return this;
	}
	
	/**
	 * Get a list of the headers that this API call will send to server.<br>
	 * <b>Note</b> that X-Token a X-Signature is not included in this bundle.
	 * @return List of headers.
	 */
	public HashMap<String, String> getHeaders() {
		return mHeaders;
	}
	
	public Api setUseCache(boolean useCache) {
		mUseCache = useCache;
		return this;
	}
	
	public boolean useCache() {
		return mUseCache;
	}
	
	/**
	 * Tell, whether to use location for this API call
	 * @param useLocation
	 * @return
	 */
	public Api setUseLocation(boolean useLocation) {
		this.useLocation = useLocation;
		return this;
	}

	/**
	 * Determine whether location is being used, for this API call
	 * @return True if location is being used, false otherwise.
	 */
	public boolean useLocation() {
		return useLocation;
	}
	
	/**
	 * Default constructor for API
	 * @param Eta object with relevant information e.g. location
	 */
	public Api(Eta eta) {
		mEta = eta;
	}
	
	public Api get(String url, RequestListener listener) {
		return request(url, listener, null, RequestType.GET, ContentType.URLENCODED, null);
	}

	public Api get(String url, RequestListener listener, Bundle apiParams) {
		return request(url, listener, apiParams, RequestType.GET, ContentType.URLENCODED, null);
	}

	public Api post(String url, RequestListener listener, Bundle apiParams) {
		return request(url, listener, apiParams, RequestType.POST, ContentType.URLENCODED, null);
	}

	public Api delete(String url, RequestListener listener, Bundle apiParams) {
		return request(url, listener, apiParams, RequestType.DELETE, ContentType.URLENCODED, null);
	}

	public Api put(String url, RequestListener listener, Bundle apiParams) {
		return request(url, listener, apiParams, RequestType.PUT, ContentType.URLENCODED, null);
	}
	
	public Api request(String url, RequestListener listener, Bundle apiParams, RequestType requestType, ContentType contentType, HashMap<String, String> headers) {
		if (url == null || listener == null || requestType == null || contentType == null) {
			Utilities.logd(TAG, "Api parameters error: url, requestListener, requestType and contentType cannot be null");
			return null;
		}
		
		// Check if RequestListener matches the URL (return values are parsed according to RequestListener)
		
		mUrl = url;
		mListenerUser = listener;
		mParams = apiParams == null ? new Bundle() : apiParams;
		mRequestType = requestType;
		mContentType = contentType;
		mHeaders = headers == null ? new HashMap<String, String>(3) : headers;
		return this;
	}

	/**
	 * This will start executing the request.
	 * Note that if the {@link #request(String, RequestListener, Bundle, RequestType, Bundle) request()}'s 
	 * optionalKeys bundle contains options that have also been set by
	 * any of the Api-setters, then the setters will be used.
	 * @return HttpHelper, so execution of background task can be cancelled. <br>
	 * <b>Note</b> HttpHelper is <code>null</code> if there is no valid session. In this case
	 * {@link #execute() execute()} will try to get a valid session and then instantiate HttpHelper, here after the previous call is continued.
	 */
	public HttpHelper execute() {

		// Check if all variables needed are okay
		if (mUrl == null || mListenerUser == null || mParams == null || mRequestType == null || mHeaders == null) {
			Utilities.logd(TAG, "A request() must be made before execute()");
			return null;
		}
		
		// Is Session okay? If not, check if it's a session call? If not try to make a session before continuing
		if (mEta.getSession().getToken() == null || mEta.getSession().getExpire() < System.currentTimeMillis()) {
			if (!mUrl.matches(Endpoint.SESSION)) {
				mEta.getSession().subscribe(new SessionListener() {
					
					public void onUpdate() {
						if (mEta.getSession().getToken() != null) {
							mEta.getSession().unSubscribe(this);
							completeExecute();							
						}
						else {
							mEta.getSession().update();
						}
					}
				});
				mEta.getSession().update();
			} else {
				completeExecute();
			}
		} else {
			completeExecute();
		}
		
		return httpHelper;
	}
	
	private void completeExecute() {

		// Prefix URL?
		if (!mUrl.matches("^http.*"))
			mUrl = Endpoint.API + mUrl;
		
		// Prepare data.
		List<NameValuePair> params = new ArrayList<NameValuePair>();

		// Add optional data.
		if (!mParams.isEmpty()) {
			Iterator<String> iterator = mParams.keySet().iterator();
			while (iterator.hasNext()) {
				String s = iterator.next();
				Utilities.putNameValuePair(params, s, mParams.get(s));
			}
		}
		
		// Required API key.
		Utilities.putNameValuePair(params, API_KEY, mEta.getApiKey());

		if (useLocation) {

			if (!mEta.getLocation().isLocationSet()) {
				Utilities.logd(TAG, "Location has not been set() yet... Aborting...");
				return;
			}
			EtaLocation l = mEta.getLocation();
			Utilities.putNameValuePair(params, EtaLocation.LATITUDE, l.getLatitude());
			Utilities.putNameValuePair(params, EtaLocation.LONGITUDE, l.getLongitude());
			Utilities.putNameValuePair(params, EtaLocation.SENSOR, l.getSensor());
			Utilities.putNameValuePair(params, EtaLocation.RADIUS, l.getRadius());

			// Determine whether to include bounds.
			if (mEta.getLocation().isBoundsSet()) {
				Utilities.putNameValuePair(params, EtaLocation.BOUND_EAST, l.getBoundEast());
				Utilities.putNameValuePair(params, EtaLocation.BOUND_NORTH, l.getBoundNorth());
				Utilities.putNameValuePair(params, EtaLocation.BOUND_SOUTH, l.getBoundSouth());
				Utilities.putNameValuePair(params, EtaLocation.BOUND_WEST, l.getBoundWest());
			}

		}
		
		// Set headers if session is OK
		if (mEta.getSession().getToken() != null) {
			setHeader(HEADER_X_TOKEN, mEta.getSession().getToken());
			String sha256 = Utilities.generateSHA256(mEta.getApiSecret() + mEta.getSession().getToken());
			setHeader(HEADER_X_SIGNATURE, sha256);
		}
		
		setHeader(HEADER_CONTENT_TYPE, mContentType.toString());
		
		List<Header> headers = new ArrayList<Header>();
		Iterator<String> it = mHeaders.keySet().iterator();
		while (it.hasNext()) {
			String string = (String) it.next();
			headers.add(new BasicHeader(string, mHeaders.get(string)));
		}
		
		// TODO: Check cache before executing the httpHepler
		if (mUseCache) {
			
		} else {

		}
		
		// Create a new HttpHelper and run it
		httpHelper = new HttpHelper(mEta, mUrl, headers, params, mRequestType, mListenerApi);
		httpHelper.execute();
		
	}

	private void doCallback(int statusCode, Object object) {
		try {
			if (mListenerUser instanceof Api.CatalogListListener) {
				ArrayList<Catalog> c = new ArrayList<Catalog>();
				JSONArray jArray = new JSONArray(object.toString());
				for (int i = 0 ; i < jArray.length() ; i++ ) {
					c.add(new Catalog((JSONObject)jArray.get(i)));
				}
				object = c;
				
			} else if  (mListenerUser instanceof Api.OfferListListener) {
				ArrayList<Offer> o = new ArrayList<Offer>();
				JSONArray jArray = new JSONArray(object.toString());
				for (int i = 0 ; i < jArray.length() ; i++ ) {
					o.add(new Offer((JSONObject)jArray.get(i)));
				}
				object = o;
				
			} else if  (mListenerUser instanceof Api.OfferListener) {
				object =  new Offer(new JSONObject(object.toString()));
				
			} else if  (mListenerUser instanceof Api.CatalogListener) {
				object = new Catalog(new JSONObject(object.toString()));
				
			} else if  (mListenerUser instanceof Api.DealerListListener) {
				ArrayList<Dealer> d = new ArrayList<Dealer>();
				JSONArray jArray = new JSONArray(object.toString());
				for (int i = 0 ; i < jArray.length() ; i++ ) {
					d.add(new Dealer((JSONObject)jArray.get(i)));
				}
				object = d;
				
			} else if  (mListenerUser instanceof Api.StoreListListener) {
				ArrayList<Offer> o = new ArrayList<Offer>();
				JSONArray jArray = new JSONArray(object.toString());
				for (int i = 0 ; i < jArray.length() ; i++ ) {
					o.add(new Offer((JSONObject)jArray.get(i)));
				}
				object = o;

			} else if  (mListenerUser instanceof Api.DealerListener) {
				object =  new Dealer(new JSONObject(object.toString()));
				
			} else if  (mListenerUser instanceof Api.StoreListener) {
				object =  new Store(new JSONObject(object.toString()));
				
			} 
		} catch (JSONException e) {
			e.printStackTrace();
		}
		mListenerUser.onComplete(statusCode, object);
	}
	
    /** Standard callback interface for API requests */
    public static interface RequestListener {
    	/**
    	 * Method called on completion of a request.<br><br>
    	 * 
    	 * Instantiate the JSON object as follows:<br>
    	 * <code>JSONObject jObject = new JSONObject(object.toString());</code>
    	 * 
    	 * @param statusCode is a standard HTTP status code
    	 * @param object is a JSON object represented as a string
    	 */
        public void onComplete(int statusCode, Object object);
    }

    /** Callback interface for a list of catalogs*/
    public static interface CatalogListListener extends RequestListener {
    	/**
    	 * Method called on completion of a request to any Catalog endpoint that returns a <i>list</i> of catalogs.<br><br>
    	 * The object returned can be one of 3 types dependent on the which range the <i>statusCode</i> is in and the <i>object</i> must be cast accordingly. <br><br>
    	 * <table border=1><thead>
    	 * <th>statusCode</th>					<th>object type</th></thead>
    	 * <tr><td>200-299 (success)</td>		<td><code>ArrayList&lt;Catalog&gt;</code></td></tr>
    	 * <tr><td>400-499 (client error)</td>	<td><code>EtaError</code></td></tr>
    	 * <tr><td>All others</td>				<td><code>String</code></td></tr>
    	 * </table><br><br>
    	 * So if you make a call to {@link com.eTilbudsavis.etasdk.Eta #getCatalogs(CatalogListListener, int) Eta.getCatalogs()} 
    	 * and the callback has statusCode == 200,<br>
    	 * you want to cast your callback object like this:<br>
    	 * <code>ArrayList&lt;Catalog&gt; c = (ArrayList&lt;Catalog&gt;)object;</code>
    	 * <br><br>
    	 * @param statusCode is a standard HTTP status code
    	 * @param object of any type above
    	 */
    	public void onComplete(int statusCode, Object object);
    }

    /** Callback interface for a list of offers */
    public static interface OfferListListener extends RequestListener {
        public void onComplete(int statusCode, Object object);
    }

    /** Callback interface for a list of dealers */
    public static interface DealerListListener extends RequestListener {
        public void onComplete(int statusCode, Object object);
    }

    /** Callback interface for a list of stores */
    public static interface StoreListListener extends RequestListener {
        public void onComplete(int statusCode, Object object);
    }

    /** Callback interface for a single catalog */
    public static interface CatalogListener extends RequestListener {
        public void onComplete(int statusCode, Object object);
    }

    /** Callback interface for a single offer */
    public static interface OfferListener extends RequestListener {
        public void onComplete(int statusCode, Object object);
    }

    /** Callback interface for a single dealer */
    public static interface DealerListener extends RequestListener {
        public void onComplete(int statusCode, Object object);
    }

    /** Callback interface for a single store */
    public static interface StoreListener extends RequestListener {
        public void onComplete(int statusCode, Object object);
    }
    
}
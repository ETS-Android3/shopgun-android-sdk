package com.shopgun.android.sdk.eventskit;

import android.content.Context;
import android.os.Bundle;

import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.shopgun.android.sdk.ShopGun;
import com.shopgun.android.sdk.utils.SgnUtils;
import com.shopgun.android.utils.PackageUtils;
import com.shopgun.android.utils.TextUtils;

import java.util.concurrent.TimeUnit;

import io.realm.RealmModel;
import io.realm.annotations.Ignore;
import io.realm.annotations.PrimaryKey;
import io.realm.annotations.RealmClass;

/**
 * Basic Event format.
 */
@RealmClass
public class Event implements RealmModel {

    public static final String TAG = Event.class.getSimpleName();
    public static final String META_APPLICATION_TRACK_ID = "com.shopgun.android.sdk.eventskit.application_track_id";
    public static final String META_APPLICATION_TRACK_ID_DEBUG = "com.shopgun.android.sdk.develop.eventskit.application_track_id";

    /* The event version scheme to use */
    public static final String VERSION = "2";
    private String mVersion = VERSION; // this field will be included into the database

    /* Default event type = empty event */
    public static final int DEFAULT_TYPE = 0;

    /* A uuid that uniquely identifies the event */
    @PrimaryKey
    private String mId;

    /* The event kind, identified by a positive integer. */
    private int mType;

    /* device time where the event completed in SECONDS */
    private long mTimestamp;

    /* Id generated by ShopGun and hardcoded into applications */
    private String mApplicationTrackId;

    /* number of retries performed */
    private int mRetryCount;

    /**** Optional common fields *****/

    /* Current user location */
    private String mGeoHash;
    private long mLocationTimestamp;

    /* Current user country */
    private String mCountry;

    /* View token */
    private String mViewToken;

    /* Additional payload: other fields defined by the event stored here as string
    *  event_key - value_type
    *  The serializer will insert these fields right after the mandatory and common fields
    */
    private String mAdditionalPayload;

    /* Tag for random properties */
    @Ignore private Object mTag;
    @Ignore private boolean mDoNotTrack;

    public Event() {
        // Init mandatory fields
        mId = SgnUtils.createUUID();
        mType = DEFAULT_TYPE;

        setTimestampInSeconds(System.currentTimeMillis());

        Context c = ShopGun.getInstance().getContext();
        Bundle b = PackageUtils.getMetaData(c);
        String trackerId = b.getString(ShopGun.getInstance().isDevelop() && b.containsKey(META_APPLICATION_TRACK_ID_DEBUG) ?
                                        META_APPLICATION_TRACK_ID_DEBUG :
                                        META_APPLICATION_TRACK_ID);
        setApplicationTrackId(TextUtils.isEmpty(trackerId) ? "" : trackerId);


        initOptionalFields();
    }

    private void initOptionalFields() {
        mGeoHash = "";
        mCountry = "";
        mViewToken = "";
        mAdditionalPayload = "";
    }

    public String getVersion() {
        return mVersion;
    }

    public void setVersion(String version) {
        mVersion = version;
    }

    public String getId() {
        return mId;
    }

    public void setId(String id) {
        mId = id;
    }

    public int getType() {
        return mType;
    }

    public void setType(int type) {
        mType = type;
    }

    /**
     * Set the timestamp fields. The input should be in millis, obtained through System.currentTimeMillis().
     * The method will take care to convert from millis to seconds
     * @param timestampInMillis as given by System.currentTimeMillis()
     */
    public void setTimestampInSeconds(long timestampInMillis) {
        mTimestamp = TimeUnit.MILLISECONDS.toSeconds(timestampInMillis);
    }

    public long getTimestamp() {
        return mTimestamp;
    }

    public void setApplicationTrackId(String id) {
        mApplicationTrackId = id;
    }

    public String getApplicationTrackId() {
        return mApplicationTrackId;
    }

    /**
     * The position of the device user at the time of the event. This is defined as two fields that must exist together.
     * @param geoHash 4 char string
     * @param timestamp timestamp of the location fix, in millis.
     *                  For smartphones, this timestamp is part of the data returned when asking for location data.
     *                  If a timestamp is unavailable, use current time.
     */
    public void setGeoHash(String geoHash, long timestamp) {
        mGeoHash = geoHash;
        mLocationTimestamp = TimeUnit.MILLISECONDS.toSeconds(timestamp);
    }

    public boolean hasLocationFields() {
        return !mGeoHash.isEmpty();
    }

    public String getGeoHash() {
        return mGeoHash;
    }

    public long getLocationTimestamp() {
        return mLocationTimestamp;
    }

    public void setCountry(String countryCode) {
        mCountry = countryCode;
    }

    public String getCountry() {
        return mCountry;
    }

    public boolean hasCountryField() {
        return !mCountry.isEmpty();
    }

    /**
     * The token must change for each piece of content.
     * For the same content on the same device = same token
     * @param token Base64 encoded 8-byte token as a string
     */
    public void setViewToken(String token) {
        mViewToken = token;
    }

    public String getViewToken() {
        return mViewToken;
    }

    public boolean hasViewToken() {
        return !mViewToken.isEmpty();
    }

    public boolean hasAdditionalPayload() {
        return !mAdditionalPayload.isEmpty();
    }

    public void setRetryCount(int retryCount) {
        mRetryCount = retryCount;
    }

    public void incrementRetryCount() {
        mRetryCount++;
    }

    public int getRetryCount() {
        return mRetryCount;
    }

    public JsonObject getPayload() {
        return parse(mAdditionalPayload);
    }

    public void setPayload(JsonObject payload) {
        if (payload != null) {
            mAdditionalPayload = payload.toString();
        }
    }

    private JsonObject parse(String json) {
        JsonParser parser = new JsonParser();
        JsonObject jsonObject;
        try {
            jsonObject = parser.parse(json).getAsJsonObject();
        } catch (Exception e) {
            jsonObject = new JsonObject();
            jsonObject.addProperty("", "");
        }
        return jsonObject;
    }

    public void setTag(Object tag) {
        mTag = tag;
    }

    public Object getTag() {
        return mTag;
    }

    public boolean doNotTrack() {
        return mDoNotTrack;
    }

    public void doNotTrack(boolean doNotTrack) {
        mDoNotTrack = doNotTrack;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("event id (_i): ").append(mId).append(", ")
                .append("event type (_e): ").append(mType)
                .append(" ").append(EzEvent.typeToString(mType)).append(", ")
                .append("timestamp (_t): ").append(mTimestamp).append(", ")
                .append("payload: ").append(mAdditionalPayload).append(", ");

        sb.append("do-not-track: ").append(mDoNotTrack).append(", ");
        if (mRetryCount > 0) {
            sb.append("mRetryCount: ").append(mRetryCount);
        }
        return sb.toString();
    }

}
